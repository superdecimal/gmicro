# 12 Factor

## How the app aligns to the 12 factor spec
|       |                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| :---: | :-----------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  1.   |      Codebase       | The code for all the services is stored under the same Git repository. The suggested flow for this app would be the [Github Flow](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/github-flow) because of the simplicity of it. Pull request are used to add features. Once the code is merged to master we can build artifacts (Docker containers) that are deployed in all the different environments.                                                    |
|  2.   |    Dependencies     | Service Dependencies are managed through **go modules** (production ready as of go 1.14). `go.mod` and `go.sum` are also stored in the repository.                                                                                                                                                                                                                                                                                                                                        |
|  3.   |       Config        | Configuration of both `calc-api` and the `cli` is managed through environment variable. Defaults are used to make running the app easier for the user.                                                                                                                                                                                                                                                                                                                                    |
|  4.   |  Backing services   | Both `calc-api` and the `cli` do not store state, but if there was a need for it we would have used URLs to configure the services. No code change would have been required to swap between backing services. The relevant config map would be updated through the Helm chart values.                                                                                                                                                                                                     |
|  5.   | Build, release, run | The Build step is where our artifacts are produced, in our case docker containers. Releasing can be triggered either through merge to master or through Github Releases depending on the needs of our project. Deployments are done with the help of Helm (although other tools exist, like Kompose). The preferred method to run the app is with a Kubernetes cluster but the use of Docker Containers means that we could easily deploy this app in another container service (ie ECS). |
|  6.   |      Processes      | The app does not require the use of state beyond the scope of a method invocation. If there was a need for state we would have used a backing service ie a database.                                                                                                                                                                                                                                                                                                                      |
|  7.   |    Port binding     | The app is bound to a configurable port.                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|  8.   |     Concurrency     | Process model is another way of saying horizontal scaling. Our app does not hold state in memory which means that it can easily scale horizontally being agnostic of how many instances are running. Kubernetes was built for this exact reason and the use of containers in our app help us achieve horizontal scaling.                                                                                                                                                                  |
|  9.   |    Disposability    | Startup time is minimal.  The app is also listening for the `SIGTERM` signal that is emitted from Kubernetes when it is trying to terminate a Pod.                                                                                                                                                                                                                                                                                                                                        |
|  10.  |   Dev/prod parity   | The same docker container can be promoted across the environments, making sure that the same code that has been tested in dev/uat has been deployed to prod. Using a tool like `minikube` can help developers emulate a prod like environment locally.                                                                                                                                                                                                                                    |
|  11.  |        Logs         | Logs are using JSON and are outputted in STDOUT, making it easier to be processed by an EFK stack.                                                                                                                                                                                                                                                                                                                                                                                        |
|  12.  |   Admin processes   | Admin tasks like database migrations could run as one off processes with the help of tools like `golang-migrate/migrate` in the same namespace as the application pods. It is easy to get console access to a running pod in case we need to debug live issues. (We have to mention that logging in to infrastructure is discouraged)                                                                                                                                                     |